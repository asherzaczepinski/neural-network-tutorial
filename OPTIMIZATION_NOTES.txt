NEURAL NETWORK TUTORIAL - PERFORMANCE OPTIMIZATIONS
===================================================

This document explains the performance optimizations made to improve
loading speed, responsiveness, and overall user experience.


1. CODE SPLITTING & LAZY LOADING
--------------------------------
PROBLEM: All 18 step components were imported at the top of page.tsx.
When the page loaded, the browser downloaded ALL step code even though
only one step is visible at a time.

SOLUTION: Used Next.js dynamic() imports to lazy-load each step.

  // Before (bad) - loads everything upfront
  import Step1 from '@/app/steps/Step1';
  import Step2 from '@/app/steps/Step2';
  // ... all 18 imports

  // After (good) - loads only when needed
  const stepComponents = Array.from({ length: 18 }, (_, i) =>
    dynamic(() => import(`@/app/steps/Step${i + 1}`), { ssr: false })
  );

RESULT: Initial page load only downloads Step 1's code. Each step is
a separate JavaScript chunk loaded on demand.


2. PRELOADING ADJACENT STEPS
----------------------------
PROBLEM: When clicking "Next", there was a delay while the next step loaded.

SOLUTION: Automatically preload the previous and next steps in the background.

  const preloadStep = (stepNum: number) => {
    if (stepNum >= 1 && stepNum <= 18) {
      import(`@/app/steps/Step${stepNum}`);
    }
  };

  useEffect(() => {
    preloadStep(currentStep + 1);
    preloadStep(currentStep - 1);
  }, [currentStep]);

RESULT: Clicking Next/Previous is now instant because the code is already
downloaded and cached.


3. SKELETON LOADING UI
----------------------
PROBLEM: When content loads, there was either a blank screen or a jarring
spinner that didn't match the content layout (causing layout shift).

SOLUTION: Created skeleton loaders that match the actual content shape.

  .skeleton {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: skeleton-shimmer 1.5s infinite;
  }

RESULT: Users see a shimmer animation in the exact shape of the content,
making the load feel faster and preventing layout shift.


4. MEMOIZED COMPONENTS
----------------------
PROBLEM: Navigation buttons were re-rendering on every state change,
even when their props didn't change.

SOLUTION: Wrapped components in React.memo() to prevent unnecessary re-renders.

  const NavButton = memo(function NavButton({ direction, onClick, disabled }) {
    return (
      <button className="nav-arrow" onClick={onClick} disabled={disabled}>
        {direction === 'prev' ? '←' : '→'}
      </button>
    );
  });

RESULT: Buttons only re-render when their specific props change.


5. USEALLBACK FOR EVENT HANDLERS
---------------------------------
PROBLEM: Event handler functions were recreated on every render, causing
child components to re-render even when nothing changed.

SOLUTION: Wrapped handlers in useCallback() to maintain stable references.

  const nextStep = useCallback(() => {
    if (currentStep < 18) goToStep(currentStep + 1);
  }, [currentStep, goToStep]);

RESULT: Memoized children receive the same function reference and skip
unnecessary re-renders.


6. OPTIMIZED SCROLL HANDLER
---------------------------
PROBLEM: Scroll events fire rapidly (60+ times per second). Processing
each one caused jank and wasted CPU cycles.

SOLUTION: Used requestAnimationFrame to batch scroll updates to once per frame.

  const handleScroll = () => {
    if (!scrollTicking.current) {
      requestAnimationFrame(() => {
        // Process scroll here
        scrollTicking.current = false;
      });
      scrollTicking.current = true;
    }
  };

RESULT: Smooth scrolling with no jank, even on slower devices.


7. MOVED CSS FROM STYLED-JSX TO GLOBALS.CSS
-------------------------------------------
PROBLEM: styled-jsx (CSS-in-JS) recalculates styles on every React render.
During window resize, this caused visible lag as styles were regenerated.

SOLUTION: Moved all page styles to globals.css (native CSS).

  // Before (slow) - styles in component
  <style jsx>{`
    .course-page { ... }
  `}</style>

  // After (fast) - styles in globals.css
  .course-page { ... }

WHY IT'S FASTER:
- Native CSS is parsed once at load time
- Browser's CSS engine handles resize (no JavaScript)
- Skips: resize → render → CSS inject → layout → paint
- Now just: resize → layout → paint


8. DISABLED SERVER-SIDE RENDERING FOR STEPS
-------------------------------------------
PROBLEM: SSR meant the server had to render components, then the client
had to "hydrate" them, causing a delay.

SOLUTION: Added ssr: false to dynamic imports.

  dynamic(() => import(`@/app/steps/Step${stepNum}`), {
    loading: () => <StepLoader />,
    ssr: false,
  });

RESULT: Faster client-side rendering since there's no hydration mismatch
to reconcile.


9. SELECTIVE ZUSTAND SUBSCRIPTION
---------------------------------
PROBLEM: Using the full store object caused re-renders whenever ANY
store value changed.

SOLUTION: Subscribe only to the specific values needed.

  // Before (bad) - subscribes to everything
  const { completeStep } = useTutorialStore();

  // After (good) - subscribes only to completeStep
  const completeStep = useTutorialStore((state) => state.completeStep);

RESULT: Component only re-renders when completeStep changes, not when
other store values change.


10. INSTANT SCROLL BEHAVIOR
---------------------------
PROBLEM: smooth scroll animation on navigation felt slow.

SOLUTION: Changed to instant scroll for snappier feel.

  window.scrollTo({ top: 0, behavior: 'instant' });

RESULT: Navigation feels more responsive.


11. RESPONSIVE SVG DIAGRAMS
---------------------------
PROBLEM: SVG diagrams had fixed pixel widths and didn't scale on mobile.

SOLUTION: Used viewBox with percentage-based width.

  <svg
    viewBox="0 0 480 160"
    preserveAspectRatio="xMidYMid meet"
    style={{ width: '100%', height: 'auto' }}
  >

RESULT: Diagrams scale smoothly to any screen size.


SUMMARY OF RESULTS
==================
- Initial load: Only downloads code for current step (~90% smaller)
- Navigation: Instant (preloaded in background)
- Resize: Smooth (native CSS, no JS overhead)
- Scrolling: 60fps (requestAnimationFrame batching)
- Re-renders: Minimized (memo, useCallback, selective subscriptions)
- Loading UX: Skeleton shimmer instead of blank/spinner


TOOLS USED
==========
- next/dynamic: Code splitting and lazy loading
- React.memo(): Prevent unnecessary re-renders
- useCallback(): Stable function references
- requestAnimationFrame(): Batch DOM updates
- CSS animations: Hardware-accelerated skeleton shimmer
- Zustand selectors: Granular store subscriptions
